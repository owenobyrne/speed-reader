---
phase: 05-reading-timing
plan: 01
type: execute
---

<objective>
Add intelligent word timing that adjusts display duration based on word length and punctuation.

Purpose: Make reading feel more natural by giving longer words and sentence endings extra time.
Output: Variable word timing system replacing the fixed interval, with smooth reading experience.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context
@.planning/phases/02-core-reader/02-01-SUMMARY.md - RSVP display patterns
@.planning/phases/04-controls-polish/04-01-SUMMARY.md - Keyboard/speed control patterns

# Key source files
@renderer.js - Current timing implementation uses setInterval with fixed delay

**Current implementation:**
- `calculateDelay(wpm)` returns fixed `60000 / wpm` ms
- `play()` uses `setInterval(advanceWord, delay)` - same delay for every word
- `setSpeed(wpm)` restarts interval with new fixed delay

**Target behavior:**
- Base delay from WPM remains the anchor
- Longer words get extra time (proportional to length)
- Punctuation (. ! ? , ; :) gets pause after
- Total reading time should approximate original WPM on average
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement word timing calculator</name>
  <files>renderer.js</files>
  <action>
Create `calculateWordDelay(word, baseDelay)` function that returns variable delay:

1. Start with baseDelay (from WPM)
2. Word length adjustment: add 15% per character above 6 chars
   - Example: 8-char word = baseDelay * (1 + 0.15 * 2) = baseDelay * 1.3
3. Punctuation pause: check word ending
   - Period/exclamation/question (. ! ?): add 50% of baseDelay
   - Comma/semicolon/colon (, ; :): add 25% of baseDelay
   - Combine with length bonus (don't replace)
4. Cap maximum delay at 3x baseDelay to prevent extreme pauses

Keep existing `calculateDelay(wpm)` as base calculation - it's used by `calculateWordDelay`.

Formula summary:
```
lengthMultiplier = 1 + max(0, (word.length - 6) * 0.15)
punctuationBonus = 0.5 for .!? or 0.25 for ,;:
delay = baseDelay * lengthMultiplier + baseDelay * punctuationBonus
return min(delay, baseDelay * 3)
```
  </action>
  <verify>Add test in console: `calculateWordDelay("hello", 200)` returns 200, `calculateWordDelay("extraordinary.", 200)` returns ~350 (length + punctuation)</verify>
  <done>Function exists, returns variable delays based on word properties</done>
</task>

<task type="auto">
  <name>Task 2: Replace fixed interval with dynamic scheduling</name>
  <files>renderer.js</files>
  <action>
Replace `setInterval` approach with `setTimeout` chaining for per-word timing:

1. Modify `advanceWord()`:
   - After displaying word, calculate delay for CURRENT word
   - Schedule next `advanceWord()` via `setTimeout` with that delay
   - Store timeout ID in `state.timeoutId` (rename from `intervalId`)

2. Modify `play()`:
   - Remove `setInterval` call
   - Just call `advanceWord()` once - it chains itself

3. Modify `pause()`:
   - Use `clearTimeout` instead of `clearInterval`
   - Update to use `state.timeoutId`

4. Modify `setSpeed()`:
   - Clear current timeout
   - No need to restart - next advanceWord will use new WPM
   - If playing, call advanceWord() to continue with new speed

5. Update state object:
   - Rename `intervalId` to `timeoutId` for clarity

Key change: instead of "every N ms advance word", it becomes "display word, then wait (variable N) ms, then display next".
  </action>
  <verify>
1. Run app, load text
2. Watch for longer pauses after periods and long words
3. Speed adjustment (arrow keys) still works mid-playback
4. Pause/play still works correctly
  </verify>
  <done>Playback uses per-word variable timing, feels more natural at sentence endings</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm start` launches without errors
- [ ] Short words display briefly, long words display longer
- [ ] Clear pause after sentences (period/!/?)
- [ ] Slight pause after commas
- [ ] Speed adjustment (up/down arrows) works during playback
- [ ] Pause (space) and resume works correctly
- [ ] Navigation (arrow left/right) still works
- [ ] No timing drift or jank at high WPM
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Reading feels more natural with variable timing
- No regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/05-reading-timing/05-01-SUMMARY.md`
</output>
